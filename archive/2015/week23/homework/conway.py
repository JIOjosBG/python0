"""
Играта „Живот“ (на английски: Game of Life, Conway's Game of Life) е популярна игра
с нула на брой играчи, измислена през 1970 година от Джон Хортън Конуей,
която се явява най-известният пример за клетъчен автомат.
Пространството на играта е (крайна или безкрайна) двумерна решетка от квадратни клетки,
всяка от които може да се намира в едно от общо две възможни състояния: жива или мъртва.
Всяка клетка от решетката взаимодейства с осемте си съседа, т.е. клетките разположени
в съседство от нея по хоризонтал, вертикал и диагонал. На итеративен принцип,
състоянието на всяка клетка в решетката запазва или променя състоянието си в зависимост
от предварително зададен списък от правила.

Играта е пример за способности като възникване (самопораждане) и самоорганизация.
С това как сложни структури се генерират от прилагането на прости правила тя
представлява интерес за физици, биолози, икономисти, математици, философи и учени
от други научни направления.

Правила на играта:

    - Всяка жива клетка с по-малко от две живи съседни клетки умира (от самота).
    - Всяка жива клетка с повече от три живи съседни клетки умира (от пренаселеност).
    - Всяка жива клетка с две или три живи съседни клетки остава жива и на следващата итерация.
    - Всяка мъртва клетка с точно три живи съседни клетки се превръща в жива клетка.

Началното състояние на полето се разглежда като своеобразен посев. На всяка итерация
(още наричана „генерация“, „поколение“) правилата на системата се прилагат едновременно
към всяка отделна клетка в полето и новите „раждания“ и „смърти“ на клетките се
случват едновременно. По този начин всяка итерация е функция, зависеща само от състоянието
на системата от предходната итерация, и няма елемент на случайност. В този смисъл
играта е за нула играчи: това означава, че развоят ѝ се определя само от началното ѝ състояние,
без да е необходима намеса от човек. Взаимодействието на човека с играта се изчерпва
със задаването на началните стойности на клетките в полето, наблюдението на развитието ѝ и
евентуалното ѝ прекъсване след определен брой итерации.

-------------------------------------------------------------------------------

Решетката ще бъде представене като списък от списъци (виж `grid` отдолу).
Клетките ще бъдат представени като числа (0 за мъртва клетка и 1 за жива).

На всяка итерация решетката се рисува.
Селд това от нея се създава решетка за следващото поколение (чрез функцията next_generation).
За целта се използвата функциите cell_value, коята определя стойността на
всяка клетка (0 или 1). На нея и е нужен броя живи съседни клетки, които се
изчисляват от функцията alive_cell_neighbours).

За да стартирате играта е нужно да инсталирате пакета pygame.
Може да го свалите от този адрес: http://www.pygame.org/download.shtml
"""

import sys
import math

import pygame
from pygame.locals import *


# Логика на играта: това трябва да напишете вие

def cell_value(current, neighbours):
    """
    Дефинирайте функция, която в зависимост от броя живи съседи на дадена
    клетка връща като разултата:
        - `1`, ако клетката трябва да е жива през следващото поколение
        - `0` в противен случай
    Използвайте правилата на играта.

    Параметри:
        - current - текуща стойност на клетката
        - neighbours - брой живи съседни клетки (изчислен от `alive_cell_neighbours`)
    """

    pass


def alive_cell_neighbours(grid, x, y):
    """
    Дефинирайте функция, която връща като резултат броя живи съседи на
    дадена клетка.

    Параметри:
        - grid - решетката
        - x, y - позиция на клетката
    """

    pass


def empty_grid(side):
    """
    Създава решетка с размер `side` x `side`, клетките на която са празни.
    Т.е. създава списък от списъки с дължина `side`, елементите на които са със стойност `0`.

    Параметри:
        - side - размер на решетката
    """

    pass


PLAYGROUND_SIDE = 480
CELLS_COUNT_PER_SIDE = 12
CELL_SIDE = PLAYGROUND_SIDE // CELLS_COUNT_PER_SIDE


def next_generation(grid):
    """
    Дефинирайте функция, която създава решетка със следващото поколение.
    За целта създвйте празна решетка `new_grid` с размер `CELLS_COUNT_PER_SIDE`.
    В клетките на новате решетка попълнете стойността от `cell_value`.

    Параметри:
        - grid: старата решетка
    """

    pass


# Това е изходната решетка
# Тя трябва да е с размер CELLS_COUNT_PER_SIDE x CELLS_COUNT_PER_SIDE
grid = [
    [0,1,1,0,0,0,0,0,1,1,0,0],
    [0,1,1,0,0,0,0,0,1,1,0,0],
    [0,0,0,1,1,0,0,0,0,0,1,1],
    [0,0,0,1,1,0,0,0,0,0,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,0,0,0,0,0,1,1,0,0],
    [0,1,1,0,0,0,0,0,1,1,0,0],
    [0,0,0,1,1,0,0,0,0,0,1,1],
    [0,0,0,1,1,0,0,0,0,0,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0],
]

# Графика

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

pygame.init()
screen = pygame.display.set_mode((PLAYGROUND_SIDE, PLAYGROUND_SIDE))
clock = pygame.time.Clock()


def draw_cell(x, y):
    r = CELL_SIDE // 2
    pygame.draw.circle(
        screen,
        WHITE,
        (x * CELL_SIDE + r, y * CELL_SIDE + r),
        r
    )


def draw_grid(grid):
    screen.fill(BLACK)
    for i in range(CELLS_COUNT_PER_SIDE):
        for j in range(CELLS_COUNT_PER_SIDE):
            cell = grid[i][j]
            if cell == 1:
                draw_cell(j, i)


while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()

    # Рисуване
    draw_grid(grid)
    pygame.display.flip()

    # Създаване на следващо поколение
    grid = next_generation(grid)

    clock.tick(2) # брой итерации в секунда
